/* 使用 use 关键字将路径引入作用域 */
// 使用 use 关键字创建一个短路径，然后就可以在作用域中任何地方使用这个更短的名字。
// 在作用域中增加 use 和路径类似于在文件系统中创建软连接。
// 通过 use 引入作用域的路径也会检查私有性，同其他路径一样。
// **注意**：use 只能创建 use 所在的特定作用域内的短路径。
// 使用 use 引入结构体、枚举和其他项时，习惯是指定他们的完整路径。

fn main() {
    println!("Hello, world!");
}


/* 使用 as 关键字提供新的名称 */
// 使用 use 将两个同名类型引入同一作用域，会出现 同名编译错误。可以在这个类型的路径后面，我们使用 as 指定一个新的本地名称或别名。
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
    Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
    Ok(())
}

/* 使用 pub use 重导出名称 */
// 使用 use 关键字，将某个名称导入当前作用域后，这个名称在此作用域中就可以使用了，但它对此作用域之外是私有的。
// 如果想让其他人调用我们的代码时，也能正常使用这个名称，就像它本来就在当前作用域一样，那我们可以将 pub 和 use 合起来使用。 这叫 “重导出（re-exporting)”:
// 我们不仅将一个名称导入了当前作用域，还允许别人把它导入他们自己的作用域。

/* 使用嵌套路径来消除大量 use 行 */
// 我们可以使用嵌套路径将相同的项在一行中引入作用域。需要指定路径相同部分，接着是两个冒号，接着是大括号中的各自不同的路径部分
use std::{cmp::Ordering, io};
// 可以在任意层级使用嵌套路径。为了在一行 use 语句中引入这两个路径，可以在嵌套中使用 self。
use std::io::{self, Write};

/* 使用 glob 运算符将所有的共有定义引入作用域 */
// 如果希望将一个路径下所有公有项引入作用域，可以指定路径后根 * , glob 运算符。
// **注意**： Glob 会使的我们难以推导作用域中有什么名称和他们是在何处定义的。
use std::collections::*;